import numpy as np
from play import evaluate_player

NUM_ACTIONS = 23
STEADY_STATE = 5
NO_IMPROVEMENT = 15
GENOME_LENGTH = NUM_ACTIONS
POPULATION_SIZE = 10
OFFSPRING_SIZE = 20
TOURNAMEN_SIZE = 5
MUTATION_PROBABILITY = 0.1
EVALUATION_IT = 5
NUM_GENERATIONS = 150

def iterated_local_search(solution):
    # Parameters
    g = 8
    temp = 1000

    # Local search to get a local optimum
    cost, sol = iterative_improvement(solution)

    # Best solution found so far
    best_sol, best_cost = sol, cost

    nb_iter = 0
    while nb_iter < NUM_ACTIONS / 2:
        # Perturbation
        sol_prime = perturb(sol, g)
        # Local search to get a new local optimum (starts from sol_prime)
        cost_second, sol_second = iterative_improvement(sol_prime)

        # Acceptance criterion : Metropolis distribution
        # If the cost generated by the second solution is lower, we keep it and restart the loop from it
        if cost_second < cost:
            sol = sol_second
            cost = cost_second
            # Update the best solution if needed
            if cost < best_cost:
                best_sol = sol
                best_cost = cost

        # If not, we will accept a worse solution with a probability depending on how worse the new solution is
        else:
            prob = np.exp((cost - cost_second) / temp)
            if np.random.choice([True, False], p=[prob, 1 - prob]):
                sol = sol_second
                cost = cost_second

        nb_iter += 1

    return best_cost, best_sol


# Iterative improvement algorithm
def iterative_improvement(solution):
    initial_solution = solution
    initial_cost = evaluate_player(EVALUATION_IT, list(initial_solution))

    # Loop until we find a local minima
    while True:
        sol, cost = first_improvement(initial_solution, initial_cost)
        if abs(cost - initial_cost) < 0.5:
            break
        initial_solution = sol
        initial_cost = cost
        print(initial_cost)
    return cost, sol


# Retrieve the first improving neighbor
def first_improvement(sol, value):
    for i in range(0, NUM_ACTIONS):
        for j in range(1, NUM_ACTIONS):
            perm = exchange(sol, i, j)
            cost = evaluate_player(EVALUATION_IT, list(perm))
            if cost < value:
                return perm, cost
    return sol, value


# Perturbation function
def perturb(sol, g):
    for i in range(g):
        sol = get_random_neighbor(sol)
    return sol


# Return a random neighbour belonging to the exchange neighbourhood
def get_random_neighbor(sol):
    neighborhood = []
    for i in range(1, len(sol)):
        for j in range(1, len(sol)):
            neighborhood.append(exchange(sol, i, j))

    # Choose a neighbour at random
    indexes = np.arange(len(neighborhood))
    index = np.random.choice(indexes)
    return neighborhood[index]


# Exchange item on index 1 with item on index 2
def exchange(sol, index1, index2):
    perm = np.copy(sol)
    perm[index1] = sol[index2]
    perm[index2] = sol[index1]
    return perm




solution = np.array(range(NUM_ACTIONS))
np.random.shuffle(solution)
print("Initial solution")
print(solution)

costs = [evaluate_player(EVALUATION_IT, list(solution))]
it = 1
while len(costs) < 2 or costs[-1] != costs[-2]:
    l1st_cost, solution = iterated_local_search(solution)
    costs.append(l1st_cost)
    print(f"Iteration {it}: last cost: {costs[-1]}")
    it += 1

print(solution)
print(costs)

